<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UBot Discord Control Panel</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Custom styles -->
    <link href="/css/main.css" rel="stylesheet">

    <!-- Preload fonts -->
    <link rel="preload" href="/fonts/gg-sans-normal.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/fonts/gg-sans-medium.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="/fonts/gg-sans-semibold.woff2" as="font" type="font/woff2" crossorigin>
</head>
<body>
<div id="app">
    <!-- App content will be loaded here -->
    <div class="container-fluid p-0">
        <div class="row g-0">
            <!-- Server list sidebar -->
            <div class="col-auto server-sidebar">
                <div id="servers-container"></div>
            </div>

            <!-- Channels and content -->
            <div class="col">
                <div class="row g-0">
                    <!-- Channel list -->
                    <div class="col-auto channel-sidebar">
                        <div id="guild-header">
                            <h3 id="guild-name">Discord Bot</h3>
                        </div>
                        <div id="channels-list"></div>
                    </div>

                    <!-- Main content area -->
                    <div class="col main-content">
                        <div id="channel-header">
                            <div id="channel-info"></div>
                        </div>
                        <div id="messages-container"></div>
                        <div id="message-input-container">
                            <form id="message-form">
                                <textarea id="message-input" placeholder="Message..." rows="1"></textarea>
                                <button type="submit" id="send-button">
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </form>
                        </div>
                    </div>

                    <!-- User list -->
                    <div class="col-auto user-sidebar">
                        <div id="users-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Loading overlay -->
<div id="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Connecting to Discord...</div>
</div>

<!-- Core libraries -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
<!-- STOMP over SockJS -->
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
<script type="text/javascript" src="/js/services/apiInterceptor.js"></script>
<script type="text/javascript" src="/js/tokenManager.js"></script>
<!-- Load DTO classes first -->
<script type="text/javascript" src="/js/dto/DiscordDTO.js"></script>
<script type="text/javascript" src="/js/dto/UserDTO.js"></script>

<script>
    // Add this to the start of your script in index.html
    document.addEventListener('DOMContentLoaded', function() {
        // Check if we have a token
        const token = localStorage.getItem('auth_token');

        // If no token, redirect to login page
        if (!token) {
            console.log('No auth token found, redirecting to login');
            window.location.href = '/login.html';
            return;
        }

        // If we have a token, validate it
        fetch('/api/auth/validate', {
            headers: {
                'Authorization': `Bearer ${token}`
            }
        })
            .then(response => {
                if (!response.ok) {
                    // Token is invalid, redirect to login
                    console.log('Invalid token, redirecting to login');
                    localStorage.removeItem('auth_token');
                    window.location.href = '/login.html';
                    return;
                }

                // Token is valid, continue loading the app
                console.log('Valid token, initializing app');
                // Initialize your app here or continue with normal flow
            })
            .catch(error => {
                console.error('Error validating token:', error);
                // On error, redirect to login to be safe
                window.location.href = '/login.html';
            });
    });
</script>

<!-- Load app scripts in non-module mode -->
<script>
    // Global config
    window.CONFIG = {
        // Application info
        APP_NAME: 'Discord Bot Control Panel',
        APP_VERSION: '1.0.0',

        // API configuration
        API: {
            BASE_URL: '/api',
            TIMEOUT: 30000, // 30 seconds
            RETRY_ATTEMPTS: 3,
            DEFAULT_ERROR_MESSAGE: 'An error occurred while communicating with the server.',
            CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
        },

        // WebSocket configuration
        WEBSOCKET: {
            ENDPOINT: '/ws',
            RECONNECT_INTERVAL: 2000, // 2 seconds
            MAX_RECONNECT_ATTEMPTS: 10,
            HEARTBEAT_INTERVAL: 30000, // 30 seconds
            HEARTBEAT_TIMEOUT: 10000, // 10 seconds
        },

        // UI configuration
        UI: {
            MESSAGE_LIMIT: 50, // Number of messages to load at once
            MAX_MESSAGES: 200, // Maximum number of messages to keep in memory
            TYPING_INDICATOR_TIMEOUT: 10000, // 10 seconds
            TOAST_DURATION: 5000, // 5 seconds
            ANIMATION_DURATION: 300, // 300 milliseconds
        },

        // Discord limits
        DISCORD: {
            MAX_MESSAGE_LENGTH: 2000,
            MAX_EMBED_LENGTH: 4000,
            MAX_FIELD_LENGTH: 1024,
            MAX_TITLE_LENGTH: 256,
            MAX_DESCRIPTION_LENGTH: 2048,
            MAX_FIELD_NAME_LENGTH: 256,
            MAX_FIELD_VALUE_LENGTH: 1024,
            MAX_FIELDS: 25,
        },

        // Debug mode (auto-enabled on localhost)
        DEBUG: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',

        // Date formatting
        DATE_FORMAT: {
            TIME: 'HH:mm',
            DATE: 'MM/DD/YYYY',
            DATETIME: 'MM/DD/YYYY HH:mm',
            RELATIVE: true, // Use relative time when possible (e.g., "2 minutes ago")
        },
    };

    // Initialize application state
    window.appState = {
        // Current user (bot)
        currentUser: null,

        // Application status
        status: {
            connected: false,
            loading: false,
            error: null
        },

        // Discord entities
        guilds: [],
        channels: [],
        users: [],
        messages: [],
        dmUsers: [],

        // Active selections
        selectedGuildId: null,
        selectedChannelId: null,
        selectedDmUserId: null,
        isDmView: true,

        // UI state
        typingUsers: new Map(), // userId -> timestamp
        notifications: []
    };

    // Store for mutation listeners
    window.stateListeners = {};

    // API module
    window.api = {
        // Base API URL
        baseUrl: '/api',

        // Cache for API responses
        cache: new Map(),

        // Generic API request function
        // Generic API request function
        async request(endpoint, options = {}, useCache = true) {
            const url = `${this.baseUrl}/${endpoint}`;
            const cacheKey = `${url}-${JSON.stringify(options)}`;

            // Check cache
            if (useCache && this.cache.has(cacheKey)) {
                const { data, timestamp } = this.cache.get(cacheKey);
                if (Date.now() - timestamp < CONFIG.API.CACHE_DURATION) {
                    return data;
                }
            }

            try {
                // Default headers
                const requestOptions = {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...(options.headers || {})
                    },
                    credentials: 'include'
                };

                // Inject Authorization header if token exists
                const token = localStorage.getItem('auth_token');
                if (token) {
                    requestOptions.headers['Authorization'] = `Bearer ${token}`;
                }
                console.log('Requesting:', url, requestOptions);
                const response = await fetch(url, requestOptions);

                if (!response.ok) {
                    // Handle 403 Forbidden globally
                    if (response.status === 403) {
                        console.warn('Received 403 response â€” redirecting to login page');
                        localStorage.removeItem('auth_token');
                        window.location.href = '/login.html?error=session_expired';
                        return Promise.reject(new Error('Session expired - redirected to login'));
                    }

                    let errorMessage;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.message || `API request failed with status ${response.status}`;
                    } catch (e) {
                        errorMessage = `API request failed with status ${response.status}: ${response.statusText}`;
                    }

                    throw new Error(errorMessage);
                }

                // Handle empty responses (204 No Content)
                let data;
                if (response.status === 204) {
                    data = null;
                } else {
                    data = await response.json();
                }

                // Cache response for GET requests
                if (useCache && (!options.method || options.method === 'GET')) {
                    this.cache.set(cacheKey, {
                        data,
                        timestamp: Date.now()
                    });
                }

                return data;
            } catch (error) {
                console.error(`API request failed: ${error.message}`, error);
                throw error;
            }
        },

        // Clear API cache
        clearCache(endpoint = null) {
            if (endpoint) {
                const prefix = `${this.baseUrl}/${endpoint}`;
                for (const key of this.cache.keys()) {
                    if (key.startsWith(prefix)) {
                        this.cache.delete(key);
                    }
                }
            } else {
                this.cache.clear();
            }
        },

        // Auth API methods
        auth: {
            login: (username, password) => api.request('auth/login', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            }),

            logout: () => api.request('auth/logout', {
                method: 'POST'
            }),

            validateToken: (token) => api.request('auth/validate', {
                headers: {
                    Authorization: `Bearer ${token}`
                }
            })
        },

        // Guild API methods
        guild: {
            getAll: () => api.request('guilds'),
            getById: (id) => api.request(`guilds/${id}`),
            getMembers: (id) => api.request(`guilds/${id}/members`),
            getChannels: (id) => api.request(`channels/guild/${id}`)
        },

        // Channel API methods
        channel: {
            getById: (id) => api.request(`channels/${id}`),
            getMessages: (id, options = {}) => {
                const params = new URLSearchParams();
                if (options.before) params.append('before', options.before);
                if (options.after) params.append('after', options.after);
                if (options.limit) params.append('limit', options.limit);

                const queryString = params.toString();
                return api.request(`messages/channel/${id}${queryString ? `?${queryString}` : ''}`);
            }
        },

        // Message API methods
        message: {
            send: (channelId, content) => api.request(`messages/channel/${channelId}`, {
                method: 'POST',
                body: JSON.stringify({ content })
            }),

            edit: (channelId, messageId, content) => api.request(`messages/${messageId}/channel/${channelId}`, {
                method: 'PUT',
                body: JSON.stringify({ content })
            }),

            delete: (channelId, messageId) => api.request(`messages/${messageId}/channel/${channelId}`, {
                method: 'DELETE'
            })
        },

        // User API methods
        user: {
            getCurrent: () => api.request('users/me'),
            getById: (id) => api.request(`users/${id}`)
        }
    };

    // Mutations for managing state
    window.mutations = {
        // Set state with dot notation support
        setState(key, value, merge = false) {
            if (key.includes('.')) {
                // Handle nested keys
                const parts = key.split('.');
                let current = window.appState;

                for (let i = 0; i < parts.length - 1; i++) {
                    if (!current[parts[i]]) {
                        current[parts[i]] = {};
                    }
                    current = current[parts[i]];
                }

                const lastKey = parts[parts.length - 1];

                if (merge && typeof current[lastKey] === 'object' && current[lastKey] !== null && typeof value === 'object') {
                    current[lastKey] = { ...current[lastKey], ...value };
                } else {
                    current[lastKey] = value;
                }
            } else {
                if (merge && typeof window.appState[key] === 'object' && window.appState[key] !== null && typeof value === 'object') {
                    window.appState[key] = { ...window.appState[key], ...value };
                } else {
                    window.appState[key] = value;
                }
            }

            // Notify listeners
            this.notifyListeners(key);
        },

        // Subscribe to state changes
        subscribe(key, callback) {
            if (!window.stateListeners[key]) {
                window.stateListeners[key] = [];
            }

            window.stateListeners[key].push(callback);

            // Return unsubscribe function
            return () => {
                window.stateListeners[key] = window.stateListeners[key].filter(cb => cb !== callback);
            };
        },

        // Notify listeners of state changes
        notifyListeners(key) {
            // Get all affected keys (including parent keys)
            const keys = [key];
            if (key.includes('.')) {
                const parts = key.split('.');
                let path = '';
                for (const part of parts) {
                    path = path ? `${path}.${part}` : part;
                    if (path !== key) {
                        keys.push(path);
                    }
                }
            }

            // Notify listeners for each key
            keys.forEach(k => {
                if (window.stateListeners[k]) {
                    window.stateListeners[k].forEach(callback => {
                        try {
                            callback(this.getNestedValue(window.appState, k));
                        } catch (error) {
                            console.error(`Error in listener for ${k}:`, error);
                        }
                    });
                }
            });

            // Notify global listeners
            if (window.stateListeners['*']) {
                window.stateListeners['*'].forEach(callback => {
                    try {
                        callback(window.appState);
                    } catch (error) {
                        console.error('Error in global state listener:', error);
                    }
                });
            }
        },

        // Get nested value from an object
        getNestedValue(obj, path) {
            const parts = path.split('.');
            let current = obj;

            for (const part of parts) {
                if (current === undefined || current === null) {
                    return undefined;
                }
                current = current[part];
            }

            return current;
        },

        // Common mutation functions
        setCurrentGuild(guildId) {
            this.setState('selectedGuildId', guildId);
            this.setState('selectedChannelId', null);
            this.setState('selectedDmUserId', null);
            this.setState('isDmView', false);
            this.setState('messages', []);
        },

        setCurrentChannel(channelId) {
            this.setState('selectedChannelId', channelId);
            this.setState('messages', []);
        },

        setCurrentDmUser(userId) {
            this.setState('selectedDmUserId', userId);
            this.setState('selectedGuildId', null);
            this.setState('selectedChannelId', null);
            this.setState('isDmView', true);
            this.setState('messages', []);
        },

        addMessage(message) {
            const messages = [...window.appState.messages, message];
            messages.sort((a, b) => a.timestamp - b.timestamp);
            this.setState('messages', messages);
        },

        updateMessage(messageId, updates) {
            const messages = [...window.appState.messages];
            const index = messages.findIndex(m => m.id === messageId);

            if (index !== -1) {
                messages[index] = {
                    ...messages[index],
                    ...updates,
                    edited: true
                };

                this.setState('messages', messages);
            }
        },

        deleteMessage(messageId) {
            const messages = window.appState.messages.filter(m => m.id !== messageId);
            this.setState('messages', messages);
        }
    };

    // Actions for app logic
    window.actions = {
        // Load initial data
        async  initialize() {
            try {
                // Set loading state
                mutations.setState('status.loading', true);

                // Load current user (bot)
                let botUser;
                try {
                    // Try different API method names for getting current user
                    if (api.user && typeof api.user.getCurrentUser === 'function') {
                        botUser = await api.user.getCurrentUser();
                    } else if (api.user && typeof api.user.getCurrent === 'function') {
                        botUser = await api.user.getCurrent();
                    } else if (api.user && typeof api.user.me === 'function') {
                        botUser = await api.user.me();
                    } else {
                        // Fallback to a direct request
                        botUser = await api.request('users/me');
                    }
                } catch (error) {
                    console.warn('Error loading current user, using default:', error);
                    botUser = {
                        id: '0',
                        name: 'Bot',
                        discriminator: '0000',
                        bot: true
                    };
                }
                mutations.setState('currentUser', botUser);

                // Load guilds
                let guilds = [];
                try {
                    // Try different API method names for getting guilds
                    if (api.guild && typeof api.guild.getGuilds === 'function') {
                        guilds = await api.guild.getGuilds();
                    } else if (api.guild && typeof api.guild.getAll === 'function') {
                        guilds = await api.guild.getAll();
                    } else if (api.guild && typeof api.guild.all === 'function') {
                        guilds = await api.guild.all();
                    } else {
                        // Fallback to a direct request
                        guilds = await api.request('guilds');
                    }
                } catch (error) {
                    console.warn('Error loading guilds:', error);
                }
                mutations.setState('guilds', guilds);

                // Initialize websocket if available
                if (window.wsHandler) {
                    const wsEndpoint = window.CONFIG?.WEBSOCKET?.ENDPOINT || '/ws';
                    // Get token from localStorage or another appropriate source
                    const token = localStorage.getItem('auth_token');

                    // Make sure to provide both the URL and token parameters
                    window.wsHandler.connect(wsEndpoint, token);
                }

                // Update UI
                if (window.ui) {
                    ui.renderServers();
                    ui.updateBotInfo();
                }

                mutations.setState('status.loading', false);
                return true;
            } catch (error) {
                console.error('Error initializing application:', error);
                mutations.setState('status.error', error.message);
                mutations.setState('status.loading', false);
                return false;
            }
        },

        // Guild and channel selection
        async selectGuild(guildId) {
            try {
                mutations.setCurrentGuild(guildId);

                // Load channels for this guild
                const channels = await api.guild.getChannels(guildId);
                mutations.setState('channels', channels);

                // Find first text channel
                const firstTextChannel = channels.find(channel => channel.type === 'TEXT');

                if (firstTextChannel) {
                    await this.selectChannel(firstTextChannel.id);
                }

                // Load guild members
                const members = await api.guild.getMembers(guildId);
                mutations.setState('users', members);

                return true;
            } catch (error) {
                console.error('Error selecting guild:', error);
                mutations.setState('status.error', error.message);
                return false;
            }
        },

        async selectChannel(channelId) {
            try {
                mutations.setCurrentChannel(channelId);

                // Show loading state
                if (window.ui) {
                    ui.showChannelLoading();
                }

                // Load messages for this channel
                const messages = await api.channel.getMessages(channelId);
                mutations.setState('messages', messages.messages || messages);

                return true;
            } catch (error) {
                console.error('Error selecting channel:', error);
                mutations.setState('status.error', error.message);
                return false;
            }
        },

        // Message operations
        async sendMessage(content) {
            try {
                if (!content || content.trim() === '') {
                    return null;
                }

                const { selectedChannelId } = window.appState;

                if (!selectedChannelId) {
                    throw new Error('No channel selected');
                }

                // Create temporary message for immediate feedback
                const tempMessage = {
                    id: `temp-${Date.now()}`,
                    content: content,
                    authorId: window.appState.currentUser?.id || '0',
                    authorName: window.appState.currentUser?.username || 'Bot',
                    authorAvatarUrl: window.appState.currentUser?.avatarUrl,
                    timestamp: Date.now(),
                    pending: true
                };

                mutations.addMessage(tempMessage);

                // Send actual message
                const message = await api.message.send(selectedChannelId, content);

                // Remove temp message
                mutations.deleteMessage(tempMessage.id);

                // Add actual message
                mutations.addMessage(message);

                return message;
            } catch (error) {
                console.error('Error sending message:', error);
                mutations.setState('status.error', error.message);
                return null;
            }
        },

        async editMessage(messageId, content) {
            try {
                if (!content || content.trim() === '') {
                    return null;
                }

                const { selectedChannelId } = window.appState;

                if (!selectedChannelId) {
                    throw new Error('No channel selected');
                }

                // Update message locally first
                mutations.updateMessage(messageId, { content, editing: true });

                // Send edit request
                const updatedMessage = await api.message.edit(selectedChannelId, messageId, content);

                // Update message
                mutations.updateMessage(messageId, {
                    ...updatedMessage,
                    editing: false
                });

                return updatedMessage;
            } catch (error) {
                console.error('Error editing message:', error);
                mutations.setState('status.error', error.message);

                // Remove editing state
                const message = window.appState.messages.find(m => m.id === messageId);
                if (message) {
                    mutations.updateMessage(messageId, { editing: false, error: true });
                }

                return null;
            }
        },

        async deleteMessage(messageId) {
            try {
                const { selectedChannelId } = window.appState;

                if (!selectedChannelId) {
                    throw new Error('No channel selected');
                }

                // Delete message locally first
                mutations.deleteMessage(messageId);

                // Send delete request
                await api.message.delete(selectedChannelId, messageId);

                return true;
            } catch (error) {
                console.error('Error deleting message:', error);
                mutations.setState('status.error', error.message);
                return false;
            }
        }
    };

    // Initialize after page load
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize app
        if (window.actions) {
            actions.initialize().then(() => {
                console.log('Application initialized successfully');

                // Hide loading overlay
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
            }).catch(error => {
                console.error('Failed to initialize application:', error);

                // Show error in loading overlay
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.innerHTML = `
                            <div class="loading-error">
                                <i class="fas fa-exclamation-circle"></i>
                                <div class="error-text">Failed to connect to Discord</div>
                                <div class="error-message">${error.message}</div>
                                <button onclick="location.reload()">Retry</button>
                            </div>
                        `;
                }
            });
        }

        // Set up UI event listeners if UI module is available
        if (window.ui && typeof ui.init === 'function') {
            ui.init();
        }
    });
</script>

<!-- WebSocket event handler -->
<script type="text/javascript" src="/js/services/WebSocketEventHandler.js"></script>
<script type="text/javascript" src="/js/services/WebSocketSessionRegistry.js"></script>

<!-- UI related script - load after WebSocket handlers -->
<script>
    // UI controller
    window.ui = {
        // DOM elements
        messagesContainer: null,
        channelsList: null,
        usersList: null,
        serversList: null,
        messageForm: null,
        messageInput: null,
        channelHeader: null,
        guildHeader: null,

        // Initialize UI
        init() {
            // Cache DOM elements
            this.messagesContainer = document.getElementById('messages-container');
            this.channelsList = document.getElementById('channels-list');
            this.usersList = document.getElementById('users-container');
            this.serversList = document.getElementById('servers-container');
            this.messageForm = document.getElementById('message-form');
            this.messageInput = document.getElementById('message-input');
            this.channelHeader = document.getElementById('channel-info');
            this.guildHeader = document.getElementById('guild-name');

            // Set up event listeners
            this.setupEventListeners();

            // Subscribe to state changes
            this.subscribeToStateChanges();

            console.log('UI initialized');
        },

        setupEventListeners() {
            // Message form submission
            if (this.messageForm) {
                this.messageForm.addEventListener('submit', (event) => {
                    event.preventDefault();

                    const content = this.messageInput.value.trim();
                    if (!content) return;

                    // Clear input
                    this.messageInput.value = '';

                    // Send message
                    window.actions.sendMessage(content);

                    // Focus input again
                    this.messageInput.focus();
                });
            }

            // Server selection
            if (this.serversList) {
                this.serversList.addEventListener('click', (event) => {
                    const serverItem = event.target.closest('.server-item');
                    if (!serverItem || serverItem.classList.contains('home')) return;

                    const guildId = serverItem.dataset.id;
                    if (guildId) {
                        window.actions.selectGuild(guildId);
                    }
                });
            }
        },

        subscribeToStateChanges() {
            // Subscribe to various state changes
            window.mutations.subscribe('guilds', () => this.renderServers());
            window.mutations.subscribe('channels', () => this.renderChannels());
            window.mutations.subscribe('users', () => this.renderUsers());
            window.mutations.subscribe('messages', () => this.renderMessages());
            window.mutations.subscribe('currentUser', () => this.updateBotInfo());
            window.mutations.subscribe('selectedGuildId', () => this.updateGuildHeader());
            window.mutations.subscribe('selectedChannelId', () => this.updateChannelHeader());
        },

        // Rendering functions
        renderServers() {
            if (!this.serversList) return;

            const guilds = window.appState.guilds;
            this.serversList.innerHTML = '';

            // Home/DM button
            const homeButton = document.createElement('div');
            homeButton.className = 'server-item home';
            homeButton.innerHTML = `
                    <div class="server-icon"><i class="fas fa-home"></i></div>
                    <div class="server-tooltip">Home</div>
                `;

            this.serversList.appendChild(homeButton);

            // Add server buttons
            guilds.forEach(guild => {
                const serverEl = document.createElement('div');
                serverEl.className = `server-item${window.appState.selectedGuildId === guild.id ? ' active' : ''}`;
                serverEl.dataset.id = guild.id;

                let iconContent;
                if (guild.iconUrl) {
                    iconContent = `<img src="${guild.iconUrl}" alt="${guild.name}">`;
                } else {
                    const initials = guild.name
                        .split(' ')
                        .map(word => word.charAt(0))
                        .join('')
                        .substring(0, 2)
                        .toUpperCase();
                    iconContent = initials;
                }

                serverEl.innerHTML = `
                        <div class="server-icon">${iconContent}</div>
                        <div class="server-tooltip">${guild.name}</div>
                    `;

                this.serversList.appendChild(serverEl);
            });
        },

        renderChannels() {
            if (!this.channelsList) return;

            const channels = window.appState.channels;
            this.channelsList.innerHTML = '';

            // Group channels by category
            const categories = {};
            const uncategorizedChannels = [];

            channels.forEach(channel => {
                if (channel.type === 'CATEGORY') {
                    categories[channel.id] = {
                        ...channel,
                        channels: []
                    };
                } else if (channel.categoryId) {
                    if (categories[channel.categoryId]) {
                        categories[channel.categoryId].channels.push(channel);
                    } else {
                        uncategorizedChannels.push(channel);
                    }
                } else {
                    uncategorizedChannels.push(channel);
                }
            });

            // Add uncategorized channels
            uncategorizedChannels
                .filter(channel => channel.type === 'TEXT' || channel.type === 'VOICE')
                .forEach(channel => {
                    const channelEl = document.createElement('div');
                    channelEl.className = `channel-item ${channel.type.toLowerCase()}${window.appState.selectedChannelId === channel.id ? ' active' : ''}`;
                    channelEl.dataset.id = channel.id;

                    let icon = '';
                    if (channel.type === 'TEXT') {
                        icon = '<span class="channel-icon"><i class="fas fa-hashtag"></i></span>';
                    } else if (channel.type === 'VOICE') {
                        icon = '<span class="channel-icon"><i class="fas fa-volume-up"></i></span>';
                    }

                    channelEl.innerHTML = `
                            ${icon}
                            <span class="channel-name">${channel.name}</span>
                        `;

                    // Add click handler
                    channelEl.addEventListener('click', () => {
                        window.actions.selectChannel(channel.id);
                    });

                    this.channelsList.appendChild(channelEl);
                });

            // Then add categories with their channels
            Object.values(categories).forEach(category => {
                // Create category header
                const categoryEl = document.createElement('div');
                categoryEl.className = 'channel-category';

                categoryEl.innerHTML = `
                        <div class="category-header">
                            <span class="category-arrow">â–¼</span>
                            <span class="category-name">${category.name}</span>
                        </div>
                    `;

                this.channelsList.appendChild(categoryEl);

                // Create container for category channels
                const channelsContainerEl = document.createElement('div');
                channelsContainerEl.className = 'category-channels';

                // Add channels in this category
                category.channels
                    .filter(channel => channel.type === 'TEXT' || channel.type === 'VOICE')
                    .forEach(channel => {
                        const channelEl = document.createElement('div');
                        channelEl.className = `channel-item ${channel.type.toLowerCase()}${window.appState.selectedChannelId === channel.id ? ' active' : ''}`;
                        channelEl.dataset.id = channel.id;

                        let icon = '';
                        if (channel.type === 'TEXT') {
                            icon = '<span class="channel-icon"><i class="fas fa-hashtag"></i></span>';
                        } else if (channel.type === 'VOICE') {
                            icon = '<span class="channel-icon"><i class="fas fa-volume-up"></i></span>';
                        }

                        channelEl.innerHTML = `
                                ${icon}
                                <span class="channel-name">${channel.name}</span>
                            `;

                        // Add click handler
                        channelEl.addEventListener('click', () => {
                            window.actions.selectChannel(channel.id);
                        });

                        channelsContainerEl.appendChild(channelEl);
                    });

                this.channelsList.appendChild(channelsContainerEl);

                // Add expand/collapse functionality
                const categoryHeader = categoryEl.querySelector('.category-header');
                categoryHeader.addEventListener('click', () => {
                    categoryEl.classList.toggle('collapsed');
                    channelsContainerEl.style.display = categoryEl.classList.contains('collapsed') ? 'none' : 'block';

                    // Update arrow
                    const arrow = categoryEl.querySelector('.category-arrow');
                    arrow.textContent = categoryEl.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
                });
            });
        },

        renderUsers() {
            if (!this.usersList) return;

            const users = window.appState.users;
            this.usersList.innerHTML = '';

            // Group users by status
            const groups = {
                online: [],
                idle: [],
                dnd: [],
                offline: []
            };

            users.forEach(user => {
                const status = user.status?.toLowerCase() || 'offline';
                if (groups[status]) {
                    groups[status].push(user);
                } else {
                    groups.offline.push(user);
                }
            });

            // Status group names
            const statusNames = {
                online: 'ONLINE',
                idle: 'IDLE',
                dnd: 'DO NOT DISTURB',
                offline: 'OFFLINE'
            };

            // Add each status group
            Object.keys(groups).forEach(status => {
                const users = groups[status];
                if (users.length === 0) return;

                // Create group header
                const groupEl = document.createElement('div');
                groupEl.className = 'user-group';

                groupEl.innerHTML = `
                        <div class="user-group-header">
                            ${statusNames[status]} - ${users.length}
                        </div>
                    `;

                // Sort users by name
                users.sort((a, b) => {
                    const nameA = a.displayName || a.name || '';
                    const nameB = b.displayName || b.name || '';
                    return nameA.localeCompare(nameB);
                });

                // Add users to group
                users.forEach(user => {
                    const userEl = document.createElement('div');
                    userEl.className = 'user-item';
                    userEl.dataset.id = user.id;

                    let avatar = '';
                    if (user.avatarUrl) {
                        avatar = `<img src="${user.avatarUrl}" alt="${user.displayName || user.name}">`;
                    } else {
                        const displayName = user.displayName || user.name;
                        const avatarText = displayName.charAt(0).toUpperCase();
                        avatar = `<div class="avatar-text">${avatarText}</div>`;
                    }

                    // Add badges
                    let badges = '';

                    // Bot badge
                    if (user.bot) {
                        badges += ' <span class="bot-badge"><i class="fas fa-robot"></i></span>';
                    }

                    // Owner badge
                    if (user.id === window.appState.guilds.find(g => g.id === window.appState.selectedGuildId)?.ownerId) {
                        badges += ' <span class="owner-badge"><i class="fas fa-crown"></i></span>';
                    }

                    userEl.innerHTML = `
                            <div class="user-avatar">
                                ${avatar}
                                <div class="user-status ${status}"></div>
                            </div>
                            <span class="user-name">${user.displayName || user.name}${badges}</span>
                        `;

                    groupEl.appendChild(userEl);
                });

                this.usersList.appendChild(groupEl);
            });
        },

        renderMessages() {
            if (!this.messagesContainer) return;

            const messages = window.appState.messages;

            // Save scroll position
            const wasAtBottom = this.isAtBottom();

            // Clear container if no messages
            if (!messages || messages.length === 0) {
                this.messagesContainer.innerHTML = `
                        <div class="welcome-message">
                            <h2>No messages yet</h2>
                            <p>Send a message to start the conversation!</p>
                        </div>
                    `;
                return;
            }

            // Otherwise, render messages
            this.messagesContainer.innerHTML = '';

            // Sort messages by timestamp
            const sortedMessages = [...messages].sort((a, b) => a.timestamp - b.timestamp);

            // Group messages by author
            let lastAuthorId = null;
            let lastTimestamp = null;
            const timestampThreshold = 5 * 60 * 1000; // 5 minutes

            sortedMessages.forEach(message => {
                // Check if this is a continuation message
                const timeDiff = lastTimestamp ? message.timestamp - lastTimestamp : Infinity;
                const isContinuation = message.authorId === lastAuthorId && timeDiff < timestampThreshold;

                // Create message element
                const messageEl = this.createMessageElement(message, isContinuation);

                // Add to container
                this.messagesContainer.appendChild(messageEl);

                // Update tracking variables
                lastAuthorId = message.authorId;
                lastTimestamp = message.timestamp;
            });

            // Scroll to bottom if we were at the bottom before
            if (wasAtBottom) {
                this.scrollToBottom();
            }
        },

        createMessageElement(message, isContinuation) {
            const messageEl = document.createElement('div');
            messageEl.className = `message-item${isContinuation ? ' continuation' : ''}`;
            messageEl.dataset.id = message.id;

            // Add special classes
            if (message.authorId === window.appState.currentUser?.id) {
                messageEl.classList.add('own-message');
            }

            if (message.pending) {
                messageEl.classList.add('pending');
            }

            if (message.error) {
                messageEl.classList.add('error');
            }

            // Prepare message content
            let content = '';

            // Avatar and author for non-continuation messages
            if (!isContinuation) {
                let avatar = '';
                if (message.authorAvatarUrl) {
                    avatar = `<img src="${message.authorAvatarUrl}" alt="${message.authorName}">`;
                } else {
                    // Use first letter of author name as avatar
                    const avatarText = message.authorName.charAt(0).toUpperCase();
                    avatar = `<div class="avatar-text">${avatarText}</div>`;
                }

                // Format timestamp
                const date = new Date(message.timestamp);
                const timestamp = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                content += `
                        <div class="message-avatar">
                            ${avatar}
                        </div>
                        <div class="message-content">
                            <div class="message-author">
                                <span class="author-name">${message.authorName}</span>
                                <span class="message-timestamp" title="${date.toLocaleString()}">
                                    ${timestamp}
                                </span>
                                ${message.edited ? '<span class="edited-indicator">(edited)</span>' : ''}
                            </div>
                    `;
            } else {
                // Continuation message has simpler header
                content += `
                        <div class="message-avatar-placeholder"></div>
                        <div class="message-content">
                    `;
            }

            // Message text
            content += `<div class="message-text">${message.content}</div>`;

            // Add attachments if any
            if (message.attachments && message.attachments.length > 0) {
                content += `<div class="message-attachments">`;

                message.attachments.forEach(attachment => {
                    if (attachment.width && attachment.height) {
                        // Image attachment
                        content += `
                                <div class="attachment-image">
                                    <a href="${attachment.url}" target="_blank">
                                        <img src="${attachment.url}" alt="${attachment.fileName}">
                                    </a>
                                </div>
                            `;
                    } else {
                        // File attachment
                        content += `
                                <div class="attachment-file">
                                    <div class="file-icon"><i class="fas fa-file"></i></div>
                                    <div class="file-info">
                                        <div class="file-name">${attachment.fileName}</div>
                                        <div class="file-size">${this.formatFileSize(attachment.size)}</div>
                                    </div>
                                    <a href="${attachment.url}" target="_blank" class="download-button">
                                        <i class="fas fa-download"></i>
                                    </a>
                                </div>
                            `;
                    }
                });

                content += `</div>`;
            }

            // Close message content div
            content += '</div>';

            messageEl.innerHTML = content;
            return messageEl;
        },

        // Helper functions
        formatFileSize(bytes) {
            if (!bytes) return '';

            if (bytes < 1024) return `${bytes} B`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
            return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
        },

        isAtBottom() {
            if (!this.messagesContainer) return false;

            return this.messagesContainer.scrollHeight - this.messagesContainer.scrollTop <= this.messagesContainer.clientHeight + 50;
        },

        scrollToBottom() {
            if (this.messagesContainer) {
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }
        },

        updateGuildHeader() {
            if (!this.guildHeader) return;

            const guildId = window.appState.selectedGuildId;

            if (guildId) {
                const guild = window.appState.guilds.find(g => g.id === guildId);
                if (guild) {
                    this.guildHeader.textContent = guild.name;
                }
            } else {
                this.guildHeader.textContent = 'Discord Bot';
            }
        },

        updateChannelHeader() {
            if (!this.channelHeader) return;

            const channelId = window.appState.selectedChannelId;

            if (channelId) {
                const channel = window.appState.channels.find(c => c.id === channelId);
                if (channel) {
                    let icon = '';
                    if (channel.type === 'TEXT') {
                        icon = '<span class="channel-icon"><i class="fas fa-hashtag"></i></span>';
                    } else if (channel.type === 'VOICE') {
                        icon = '<span class="channel-icon"><i class="fas fa-volume-up"></i></span>';
                    }

                    this.channelHeader.innerHTML = `
                            ${icon}
                            <span class="channel-name">${channel.name}</span>
                        `;
                }
            }
        },

        updateBotInfo() {
            const botUser = window.appState.currentUser;
            if (!botUser) return;

            // Update relevant UI elements with bot info
            const botNameElement = document.querySelector('.bot-name');
            if (botNameElement) {
                botNameElement.textContent = botUser.name;
            }
        },

        showChannelLoading() {
            if (!this.messagesContainer) return;

            this.messagesContainer.innerHTML = `
                    <div class="loading-container">
                        <div class="loading-spinner"></div>
                        <div class="loading-text">Loading messages...</div>
                    </div>
                `;
        },

        showToast(message, type = 'info') {
            // Remove existing toasts
            document.querySelectorAll('.toast').forEach(toast => {
                toast.remove();
            });

            // Create toast
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `<div class="toast-content">${message}</div>`;

            // Add to document
            document.body.appendChild(toast);

            // Show toast
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Remove after delay
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }
    };
</script>

<script>
    // Basic error handling for API testing
    async function testAuth() {
        try {
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    username: 'admin',
                    password: 'password'
                })
            });

            const contentType = response.headers.get('content-type');
            console.log('Auth response content type:', contentType);

            if (contentType && contentType.includes('application/json')) {
                const data = await response.json();
                console.log('Auth response data:', data);
            } else {
                const text = await response.text();
                console.log('Auth response text (first 100 chars):', text.slice(0, 100));
            }
        } catch (error) {
            console.error('Auth test error:', error);
        }
    }

    // Call this function when page loads
    document.addEventListener('DOMContentLoaded', testAuth);
</script>
</body>
</html>